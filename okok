this is my PostController.java

package com.iss.controllers;

import java.util.List;
import java.util.Optional;

import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.http.ResponseEntity;
import org.springframework.web.bind.annotation.CrossOrigin;
import org.springframework.web.bind.annotation.DeleteMapping;
import org.springframework.web.bind.annotation.GetMapping;
import org.springframework.web.bind.annotation.PatchMapping;
import org.springframework.web.bind.annotation.PathVariable;
import org.springframework.web.bind.annotation.PostMapping;
import org.springframework.web.bind.annotation.PutMapping;
import org.springframework.web.bind.annotation.RequestBody;
import org.springframework.web.bind.annotation.RequestMapping;
import org.springframework.web.bind.annotation.RestController;

import com.iss.entity.Posts;
import com.iss.services.PostService;


@CrossOrigin(origins = "*", allowedHeaders = "*")
@RestController
@RequestMapping("/api/posts")
public class PostsController {
	
	
	
	@Autowired
	private PostService postService;
	
	
	
	@GetMapping("/all")
	public List<Posts> showAllPosts(){
		
		
		return postService.showAllPosts();
		
	}
	
	@GetMapping("/byid/{postid}")
	public ResponseEntity<Optional<Posts>> getPostById(@PathVariable Long postid){
		Optional<Posts> posts=postService.getByPostId(postid);
		return ResponseEntity.ok(posts);
	}
	
	
	@PostMapping("/create")
	public ResponseEntity<Posts> createPost(@RequestBody Posts posts){
		
		try {
		Posts createdPost = postService.createPost(posts);
		return ResponseEntity.ok(createdPost);
		}
		catch(Exception e) {
			return ResponseEntity.badRequest().build();
			
		}
	}
	
	@PutMapping("/edit/{postid}")
	public ResponseEntity<Posts> editPost(@PathVariable long postid,@RequestBody Posts posts){
		try {
			posts.setPost_id(postid);
			Posts editedPost=postService.editPost(postid, posts);
			if(editedPost!=null)
			{
				return ResponseEntity.ok(editedPost);
			}
			else
			{return ResponseEntity.notFound().build();
			}
			
			}
		 catch (Exception e) {
	            return ResponseEntity.badRequest().build();
	        }
			
		}
	
	
	@PutMapping("/togglestatus/{postid}")
	public Posts toggleStatus(@PathVariable long postid) {
		return postService.toggleStatus(postid);
		
	}
	
	
	
	 @DeleteMapping("/delete/{postid}")
	public ResponseEntity<Void> deletePost(@PathVariable long postid){
		try {
			postService.deletePost(postid);
			return ResponseEntity.noContent().build();			
		}
		catch(Exception e) {
			return ResponseEntity.notFound().build();
		}
		}
	
	}

CategoryConroller.java

package com.iss.controllers;

import java.util.List;

import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.web.bind.annotation.CrossOrigin;
import org.springframework.web.bind.annotation.GetMapping;
import org.springframework.web.bind.annotation.RequestMapping;
import org.springframework.web.bind.annotation.RestController;

import com.iss.entity.Category;
import com.iss.services.CategoryService;


@CrossOrigin(origins = "*", allowedHeaders = "*")
@RestController
@RequestMapping("/category")
public class CategoryController {

    @Autowired	
	private CategoryService categoryService;
    
    
    @GetMapping("/all")
    public List<Category> getAllCategory(){
    	return categoryService.getAllCategory();
    }
    
}



Post.java

package com.iss.entity;


import java.time.OffsetDateTime;

import jakarta.persistence.Column;
import jakarta.persistence.Entity;
import jakarta.persistence.GeneratedValue;
import jakarta.persistence.GenerationType;
import jakarta.persistence.Id;
import jakarta.persistence.JoinColumn;
import jakarta.persistence.Lob;
import jakarta.persistence.ManyToOne;
import jakarta.persistence.PrePersist;
import jakarta.persistence.SequenceGenerator;
import jakarta.persistence.Table;

@Entity
@Table(name = "POSTS", schema = "NEWSO")
public class Posts {

	@Id
	@Column(name = "POST_SEQ_ID", nullable = false)
	private long post_id;
	@Column(name = "POST_HEADER", nullable = false)
	private String post_header;

	@Lob
	@Column(name = "POST_CONTENT", columnDefinition = "CLOB", nullable = false)
	private String post_content;

	@Column(name = "STATUS", nullable = false)
	private String status;

	@Column(name = "POSTED_BY", nullable = false)
	private String posted_by;
	
	@Column(name = "POSTED_AT", columnDefinition="TIMESTAMP WITH TIME ZONE", nullable = false)
	private OffsetDateTime posted_at;
	
	@ManyToOne
	@JoinColumn(name="CATEGORY_ID",nullable=false)
	private Category category;
	
	
	@PrePersist
	protected void onCreate() {
		if(posted_at==null) {
			posted_at=OffsetDateTime.now();
		}
	}

	public long getPost_id() {
		return post_id;
	}

	public void setPost_id(long post_id) {
		this.post_id = post_id;
	}

	public String getPost_header() {
		return post_header;
	}

	public void setPost_header(String post_header) {
		this.post_header = post_header;
	}

	public String getPost_content() {
		return post_content;
	}

	public void setPost_content(String post_content) {
		this.post_content = post_content;
	}

	public String getStatus() {
		return status;
	}

	public void setStatus(String status) {
		this.status = status;
	}

	public String getPosted_by() {
		return posted_by;
	}

	public void setPosted_by(String posted_by) {
		this.posted_by = posted_by;
	}

	public OffsetDateTime getPosted_at() {
		return posted_at;
	}

	public void setPosted_at(OffsetDateTime posted_at) {
		this.posted_at = posted_at;
	}

	public Category getCategory() {
		return category;
	}

	public void setCategory(Category category) {
		this.category = category;
	}
	
	

}


Category.java}


package com.iss.entity;

import java.util.List;

import com.fasterxml.jackson.annotation.JsonIgnore;

import jakarta.persistence.CascadeType;
import jakarta.persistence.Column;
import jakarta.persistence.Entity;
import jakarta.persistence.FetchType;
import jakarta.persistence.GeneratedValue;
import jakarta.persistence.GenerationType;
import jakarta.persistence.Id;
import jakarta.persistence.OneToMany;
import jakarta.persistence.Table;

@Entity
@Table(name="CATEGORY", schema="NEWSO")
public class Category {
	
	
	@Id
	@GeneratedValue(strategy = GenerationType.IDENTITY)
	@Column(name="CATEGORY_ID")
	private Long categoryId;
	
	
	@Column(name="CATEGORY_NAME", nullable = false)
	private String categoryName;
	
	@JsonIgnore
	@OneToMany(mappedBy = "category",cascade=CascadeType.ALL, fetch=FetchType.LAZY)
	private List<Posts> posts;


	public Long getCategoryId() {
		return categoryId;
	}


	public void setCategoryId(Long categoryId) {
		this.categoryId = categoryId;
	}


	public String getCategoryName() {
		return categoryName;
	}


	public void setCategoryName(String categoryName) {
		this.categoryName = categoryName;
	}


	public List<Posts> getPosts() {
		return posts;
	}


	public void setPosts(List<Posts> posts) {
		this.posts = posts;
	}
	
	
	
	
	

}


PostsRepository.java



package com.iss.repo;

import org.springframework.data.jpa.repository.JpaRepository;

import com.iss.entity.Posts;

public interface PostsRepository extends JpaRepository<Posts, Long>{

}
 

CategoryRepository.java
package com.iss.repo;

import org.springframework.data.jpa.repository.JpaRepository;

import com.iss.entity.Category;

public interface CategoryRepository extends JpaRepository<Category, Long> {

}


CategorySerice.java
package com.iss.services;

import java.util.List;

import com.iss.entity.Category;

public interface CategoryService {
	
	
	public List<Category> getAllCategory();

}

CategoryServiceImpl.java
package com.iss.services;

import java.util.List;

import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.stereotype.Service;

import com.iss.entity.Category;
import com.iss.repo.CategoryRepository;


@Service
public class CategroyServiceImpl implements CategoryService {
	
	
	@Autowired
	private CategoryRepository categoryRepository;

	@Override
	public List<Category> getAllCategory() {
	
		return categoryRepository.findAll();
	}

}


PostService.java

package com.iss.services;

import java.util.List;
import java.util.Optional;

import com.iss.entity.Posts;

public interface PostService {
	

public Optional<Posts> getByPostId(long postid);
	
public List<Posts> showAllPosts();

public Posts createPost(Posts posts);

public Posts editPost(long postid,Posts posts);

public void deletePost(long postid);

Posts toggleStatus(Long postid);

}

PostServiceImpl.java
package com.iss.services;

import java.util.List;
import java.util.Optional;

import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.stereotype.Service;

import com.iss.entity.Category;
import com.iss.entity.Posts;
import com.iss.repo.CategoryRepository;
import com.iss.repo.PostsRepository;

@Service
public class PostServiceImpl implements PostService{
	
	@Autowired
	private PostsRepository postRepository;
	
	
	@Autowired
	private CategoryRepository categoryRepository;

	@Override
	public List<Posts> showAllPosts() {
		
		return postRepository.findAll();
	}

	@Override
	public Posts createPost(Posts post) {
	    if (post.getCategory() != null && post.getCategory().getCategoryId() != null) {
	        Category category = categoryRepository.findById(post.getCategory().getCategoryId())
	                .orElseThrow(() -> new IllegalArgumentException("Invalid Category ID"));
	        post.setCategory(category);
	    }
	    return postRepository.save(post);
	}

	@Override
	public void deletePost(long postid) {
		if(postRepository.existsById(postid)) {
			this.postRepository.deleteById(postid);
		}
		else {
            throw new IllegalArgumentException("Post with ID " + postid + " not found");
        }
		
	}

	@Override
	public Posts editPost(long postid, Posts post) {
	    if (!postRepository.existsById(postid)) {
	        return null;
	    }

	    post.setPost_id(postid);
	    if (post.getCategory() != null && post.getCategory().getCategoryId() != null) {
	        Category category = categoryRepository.findById(post.getCategory().getCategoryId())
	                .orElseThrow(() -> new IllegalArgumentException("Invalid Category ID"));
	        post.setCategory(category);
	    }

	    return postRepository.save(post);
	}

	@Override
	public Posts toggleStatus(Long postid) {
		Optional<Posts> postOptional = postRepository.findById(postid);
		if(postOptional.isPresent()) {
			Posts posts=postOptional.get();
			posts.setStatus(posts.getStatus().equals("ACTIVE")?"INACTIVE" : "ACTIVE");
			return postRepository.save(posts);
			
		}
		return null;
	}

	@Override
	public Optional<Posts> getByPostId(long postid) {
		
		return postRepository.findById(postid);
	}
	
	
	
	
	
	

}



this is my backend code check for error







tnewpost.component.html

<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Post Submission Form</title>
    <style>
    

    </style>
</head>
<body>

    <div class="container" [ngClass]="{'edit-mode': isEditMode}">
        <form>
            <div class="editid" *ngIf="isEditMode" hidden>
                <label for="postId">Post ID</label>
                <input type="text" id="postId" name="postId" [(ngModel)]="post.post_id" readonly>
            </div>

            <div class="editstatus" *ngIf="isEditMode">
                <label for="status">Status</label>
                <select id="status" name="status" [(ngModel)]="post.status">
                    <option value="ACTIVE">ACTIVE</option>
                    <option value="INACTIVE">INACTIVE</option>
                </select>
            </div>

            <div class="form-group" hidden>
                <label for="postedBy">Posted By</label>
                <input type="text" id="postedBy" name="postedBy" [(ngModel)]="post.posted_by" readonly>
            </div>
            
          
            
            <div class="form-group" *ngIf="!isEditMode">
                <label for="postHeader">Post Heading</label>
                <input type="text" id="postHeader" name="postHeader" [(ngModel)]="post.post_header" [readonly]="isViewMode" placeholder="Enter New Post Heading Here" required>
            </div>

            <div class="editheader" *ngIf="isEditMode">
                <label for="postHeader">Post Heading</label>
                <input type="text" id="postHeader" name="postHeader" [(ngModel)]="post.post_header" [readonly]="isViewMode"  required>
            </div>


           
           

            <div class="contentbox" *ngIf="!isEditMode">
                <label for="postContent">Post Content</label>
                <textarea id="postContent" name="postContent" [(ngModel)]="post.post_content" [readonly]="isViewMode" placeholder="Enter New Post Content Here" required></textarea>
            </div>

            <div class="editcontentbox" *ngIf="isEditMode">
                <label for="postContent">Post Content</label>
                <textarea class="edittextarea" id="postContent" name="postContent" [(ngModel)]="post.post_content" [readonly]="isViewMode" required></textarea>
            </div>

           <!-- Category Dropdown -->
           <div class="cat">
            <label for="category">Category</label>
            <select id="category" name="categoryId" [(ngModel)]="post.categoryId" required>
              <option *ngFor="let category of categories" [value]="category.id">
                {{ category.name }}
              </option>
            </select>
          </div>
           

            <div class="button-group" *ngIf="!isEditMode && !isViewMode">
                <button type="submit" (click)="submitPostForm()" routerLink="">{{ isEditMode ? 'Update' : 'Submit' }}</button>
                <button type="button" routerLink="/home" class="cancel-btn">Cancel</button>
            </div>

            <div class="editpostbuttons" *ngIf="isEditMode">
                <button type="submit" (click)="submitPostForm()" routerLink="">{{ isEditMode ? 'Update' : 'Submit' }}</button>
                <button type="button" routerLink="/home" class="cancel-btn">Cancel</button>
            </div>

        </form>

        <div class="illustration">
            <img src=""*ngIf="!isEditMode">
        </div>


        
    </div>

    <p *ngIf="responseMessage">{{ responseMessage }}</p>

</body>
</html>

newpost.component.ts

import { Component, OnInit } from '@angular/core';
import { ActivatedRoute, Router } from '@angular/router';
import { PostService } from '../../services/post.service';
import { Post } from '../../services/post.model';
import { LoginService } from '../../services/login.service';

@Component({
  selector: 'app-new-post',
  standalone: false,
  templateUrl: './new-post.component.html',
  styleUrl: './new-post.component.css'
})
export class NewPostComponent implements OnInit {
 
  posts: Post[] = [];
  isEditMode = false;
  isViewMode = false;
  statusValue : string="ACTIVE";

  categories: any[] = [];


  post = {
    post_id: 0, 
    post_header: '',
    post_content: '',
    status: 'ACTIVE',
    posted_by: '',
    posted_at: '',
    categoryId:0
  };

  responseMessage: string = '';

  constructor(
    private postService: PostService,
    private route: ActivatedRoute,
    private router: Router,
    private loginService:LoginService
  ) {}

  ngOnInit(): void {

   const storedUsername=this.loginService.getUsername();
   if(storedUsername){
    this.post.posted_by=storedUsername;
   }
   

    this.postService.getCategories().subscribe(data=>{
      this.categories=data;
    });

   
    this.route.params.subscribe(params => {
      const postId = params['id'];
      if (postId) {
        this.isEditMode = true;
      
        const numericPostId = Number(postId);

        this.route.queryParams.subscribe(queryParams => {
          if (queryParams['mode'] === 'view') {
            this.isViewMode = true;
            this.isEditMode = false; // Prevent editing in view mode
          }
        });
        
        // Get the post data for editing
        this.postService.getPosts().subscribe(posts => {
          this.posts = posts;
          const postToEdit = this.posts.find(p => p.post_id === numericPostId);
          if (postToEdit) {
            // Make a type-safe copy
            this.post = {
              post_id: postToEdit.post_id,
              post_header: postToEdit.post_header,
              post_content: postToEdit.post_content,
              status: postToEdit.status,
              posted_by: postToEdit.posted_by,
              posted_at: postToEdit.posted_at,
              categoryId: postToEdit.categoryId||0
            };
          } else {
            this.responseMessage = 'Post not found!';
          }
        });
      }
    });
  }

  submitPostForm() {
    if (this.isEditMode) {
      // Update existing post
      this.postService.editPost(this.post as Post).subscribe({
        next: (response) => {
          this.responseMessage = 'Post updated successfully!';
        
        },
        error: (error) => {
          this.responseMessage = 'Failed to update post!';
        }
      });
    } else {
      // Create new post
     
        this.postService.createPost(this.post).subscribe({
          next: (response) => {
            this.responseMessage = 'Post created successfully!';
            console.log("okokzz");
            this.post = {
              post_id: 0, 
              post_header: '',
              post_content: '',
              status: '',
              posted_by: '',
              posted_at: '',
              categoryId: 0
            };
       
          },
          error: (error) => {
            console.log("nonokzz");
            this.responseMessage = 'Failed to submit data!';
          }
        });
      
    }
  }

  cancelForm() {
    this.router.navigate(['/home']);
  }
}


post.model.ts

export interface Post{
    post_id : number;
    post_header : string;
    post_content : string;
    status: string;
    posted_by:string;
    posted_at: string; 
    categoryId: number;

}

post.service.ts

import { HttpClient } from '@angular/common/http';
      import { Injectable } from '@angular/core';
      import { Observable } from 'rxjs';
      import {Post} from './post.model';

      @Injectable({
        providedIn: 'root'
      })
      export class PostService {

        private apiUrlt='http://localhost:8080/api/posts/all';
        private posturl='http://localhost:8080/api/posts/create';
        private deleteurl='http://localhost:8080/api/posts/delete';
        private editurl='http://localhost:8080/api/posts/edit';
        private toggleurl='http://localhost:8080/api/posts/togglestatus';

        constructor(private http:HttpClient) { }

        getPosts(): Observable<Post[]>{
          return this.http.get<Post[]>(this.apiUrlt);
        }

        togglestatus(post_id:number):Observable<any>{
          return this.http.put(`${this.toggleurl}/${post_id}`,{});
        }

        createPost(data:any):Observable<any>{
          return this.http.post(this.posturl,data);
        }

        editPost(post:Post):Observable<Post>{
          return this.http.put<Post>(`${this.editurl}/${post.post_id}`,post);
        }

        deletePost(postid: number ):Observable<any>{
          return this.http.delete(`${this.deleteurl}/${postid}`)
        }

        getPostById(postId: number): Observable<Post> {
          return this.http.get<Post>(`http://localhost:8080/api/posts/byid/${postId}`);
        }
        
        getCategories(){
          return this.http.get<any[]>('http://localhost:8080/category/all');
        }


      }





its not displaing drop down category values and in jason response its showing undifned for categoryid and null value is savin in databae fix this 
<div class="container" [ngClass]="{'edit-mode': isEditMode}">
  <form>
    <!-- Post ID (hidden in edit mode) -->
    <div class="editid" *ngIf="isEditMode" hidden>
      <label for="postId">Post ID</label>
      <input type="text" id="postId" name="postId" [(ngModel)]="post.post_id" readonly>
    </div>

    <!-- Status dropdown (only in edit mode) -->
    <div class="editstatus" *ngIf="isEditMode">
      <label for="status">Status</label>
      <select id="status" name="status" [(ngModel)]="post.status">
        <option value="ACTIVE">ACTIVE</option>
        <option value="INACTIVE">INACTIVE</option>
      </select>
    </div>

    <!-- Posted By (hidden) -->
    <div class="form-group" hidden>
      <label for="postedBy">Posted By</label>
      <input type="text" id="postedBy" name="postedBy" [(ngModel)]="post.posted_by" readonly>
    </div>

    <!-- Post Header -->
    <div class="form-group" *ngIf="!isEditMode">
      <label for="postHeader">Post Heading</label>
      <input type="text" id="postHeader" name="postHeader" [(ngModel)]="post.post_header" [readonly]="isViewMode" placeholder="Enter New Post Heading Here" required>
    </div>

    <div class="editheader" *ngIf="isEditMode">
      <label for="postHeader">Post Heading</label>
      <input type="text" id="postHeader" name="postHeader" [(ngModel)]="post.post_header" [readonly]="isViewMode" required>
    </div>

    <!-- Post Content -->
    <div class="contentbox" *ngIf="!isEditMode">
      <label for="postContent">Post Content</label>
      <textarea id="postContent" name="postContent" [(ngModel)]="post.post_content" [readonly]="isViewMode" placeholder="Enter New Post Content Here" required></textarea>
    </div>

    <div class="editcontentbox" *ngIf="isEditMode">
      <label for="postContent">Post Content</label>
      <textarea class="edittextarea" id="postContent" name="postContent" [(ngModel)]="post.post_content" [readonly]="isViewMode" required></textarea>
    </div>

    <!-- Category Dropdown -->
    <div class="form-group">
      <label for="category">Category</label>
      <select id="category" name="categoryId" [(ngModel)]="post.categoryId" required>
        <option *ngFor="let category of categories" [value]="category.id">
          {{ category.name }}
        </option>
      </select>
    </div>

    <!-- Buttons -->
    <div class="button-group" *ngIf="!isEditMode && !isViewMode">
      <button type="submit" (click)="submitPostForm()" routerLink="">{{ isEditMode ? 'Update' : 'Submit' }}</button>
      <button type="button" routerLink="/home" class="cancel-btn">Cancel</button>
    </div>

    <div class="editpostbuttons" *ngIf="isEditMode">
      <button type="submit" (click)="submitPostForm()" routerLink="">{{ isEditMode ? 'Update' : 'Submit' }}</button>
      <button type="button" routerLink="/home" class="cancel-btn">Cancel</button>
    </div>
  </form>

  <div class="illustration">
    <img src="" *ngIf="!isEditMode">
  </div>
</div>

<p *ngIf="responseMessage">{{ responseMessage }}</p>



@@@@@

import { Component, OnInit } from '@angular/core';
import { ActivatedRoute, Router } from '@angular/router';
import { PostService } from '../../services/post.service';
import { Post } from '../../services/post.model';
import { LoginService } from '../../services/login.service';

@Component({
  selector: 'app-new-post',
  standalone: false,
  templateUrl: './new-post.component.html',
  styleUrl: './new-post.component.css'
})
export class NewPostComponent implements OnInit {
 
  posts: Post[] = [];
  isEditMode = false;
  isViewMode = false;
  statusValue : string="ACTIVE";


  post = {
    post_id: 0, 
    post_header: '',
    post_content: '',
    status: 'ACTIVE',
    posted_by: '',
    posted_at: '' 
  };

  responseMessage: string = '';

  constructor(
    private postService: PostService,
    private route: ActivatedRoute,
    private router: Router,
    private loginService:LoginService
  ) {}

  ngOnInit(): void {

   const storedUsername=this.loginService.getUsername();
   if(storedUsername){
    this.post.posted_by=storedUsername;
   }


   
    this.route.params.subscribe(params => {
      const postId = params['id'];
      if (postId) {
        this.isEditMode = true;
      
        const numericPostId = Number(postId);

        this.route.queryParams.subscribe(queryParams => {
          if (queryParams['mode'] === 'view') {
            this.isViewMode = true;
            this.isEditMode = false; // Prevent editing in view mode
          }
        });
        
        // Get the post data for editing
        this.postService.getPosts().subscribe(posts => {
          this.posts = posts;
          const postToEdit = this.posts.find(p => p.post_id === numericPostId);
          if (postToEdit) {
            // Make a type-safe copy
            this.post = {
              post_id: postToEdit.post_id,
              post_header: postToEdit.post_header,
              post_content: postToEdit.post_content,
              status: postToEdit.status,
              posted_by: postToEdit.posted_by,
              posted_at: postToEdit.posted_at
            };
          } else {
            this.responseMessage = 'Post not found!';
          }
        });
      }
    });
  }

  submitPostForm() {
    if (this.isEditMode) {
      // Update existing post
      this.postService.editPost(this.post as Post).subscribe({
        next: (response) => {
          this.responseMessage = 'Post updated successfully!';
        
        },
        error: (error) => {
          this.responseMessage = 'Failed to update post!';
        }
      });
    } else {
      // Create new post
     
        this.postService.createPost(this.post).subscribe({
          next: (response) => {
            this.responseMessage = 'Post created successfully!';
            console.log("okokzz");
            this.post = {
              post_id: 0, 
              post_header: '',
              post_content: '',
              status: '',
              posted_by: '',
              posted_at: ''
            };
       
          },
          error: (error) => {
            console.log("nonokzz");
            this.responseMessage = 'Failed to submit data!';
          }
        });
      
    }
  }

  cancelForm() {
    this.router.navigate(['/home']);
  }
}

and html

<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Post Submission Form</title>
    <style>
    

    </style>
</head>
<body>

    <div class="container" [ngClass]="{'edit-mode': isEditMode}">
        <form>
            <div class="editid" *ngIf="isEditMode" hidden>
                <label for="postId">Post ID</label>
                <input type="text" id="postId" name="postId" [(ngModel)]="post.post_id" readonly>
            </div>

            <div class="editstatus" *ngIf="isEditMode">
                <label for="status">Status</label>
                <select id="status" name="status" [(ngModel)]="post.status">
                    <option value="ACTIVE">ACTIVE</option>
                    <option value="INACTIVE">INACTIVE</option>
                </select>
            </div>

            <div class="form-group" hidden>
                <label for="postedBy">Posted By</label>
                <input type="text" id="postedBy" name="postedBy" [(ngModel)]="post.posted_by" readonly>
            </div>
            
          
            
            <div class="form-group" *ngIf="!isEditMode">
                <label for="postHeader">Post Heading</label>
                <input type="text" id="postHeader" name="postHeader" [(ngModel)]="post.post_header" [readonly]="isViewMode" placeholder="Enter New Post Heading Here" required>
            </div>

            <div class="editheader" *ngIf="isEditMode">
                <label for="postHeader">Post Heading</label>
                <input type="text" id="postHeader" name="postHeader" [(ngModel)]="post.post_header" [readonly]="isViewMode"  required>
            </div>


           
           

            <div class="contentbox" *ngIf="!isEditMode">
                <label for="postContent">Post Content</label>
                <textarea id="postContent" name="postContent" [(ngModel)]="post.post_content" [readonly]="isViewMode" placeholder="Enter New Post Content Here" required></textarea>
            </div>

            <div class="editcontentbox" *ngIf="isEditMode">
                <label for="postContent">Post Content</label>
                <textarea class="edittextarea" id="postContent" name="postContent" [(ngModel)]="post.post_content" [readonly]="isViewMode" required></textarea>
            </div>

           

           

            <div class="button-group" *ngIf="!isEditMode && !isViewMode">
                <button type="submit" (click)="submitPostForm()" routerLink="">{{ isEditMode ? 'Update' : 'Submit' }}</button>
                <button type="button" routerLink="/home" class="cancel-btn">Cancel</button>
            </div>

            <div class="editpostbuttons" *ngIf="isEditMode">
                <button type="submit" (click)="submitPostForm()" routerLink="">{{ isEditMode ? 'Update' : 'Submit' }}</button>
                <button type="button" routerLink="/home" class="cancel-btn">Cancel</button>
            </div>

        </form>

        <div class="illustration">
            <img src=""*ngIf="!isEditMode">
        </div>


        
    </div>

    <p *ngIf="responseMessage">{{ responseMessage }}</p>

</body>
</html>

so add that catergoy feature in this my code
